package com.incture.bomnr.service;



import org.hibernate.Criteria;
import org.hibernate.Session;

import org.hibernate.criterion.Restrictions;

import com.incture.bomnr.entity.BomnrSeqNumberDo;


public class SequenceNumberGen {

	private static SequenceNumberGen sequenceNumberGenerator;
	
   
	
	BomnrSeqNumberDo sequenceNumbersDo =null;
	private static int oldRunningNumber=0;
	private static String oldRefCode="";
	public SequenceNumberGen() {
	}

	public static synchronized SequenceNumberGen getInstance() {
		return sequenceNumberGenerator == null ? sequenceNumberGenerator = new SequenceNumberGen()
				: sequenceNumberGenerator;
	}

	/**
	 * Generates a code in CCCCXXYYYYMMNNNN format, where CCCC is Company Code,
	 * XX is Transaction Type, YYYY is year, MM is Month, NNNN is the number
	 * generated by this function. Input field <code>referenceCode</code> is
	 * CCCCXXYYYYMM and <code>noOfDigits</code> indicate size of NNNN. Function
	 * uses a variable of hash map data structure with application scope, where
	 * referenceCode parameter is the key and running number(sequential,
	 * incremented by 1, starting from 0) is the value. Function is thread-safe,
	 * map variable is lazy loaded once, and value persist to relevant table in
	 * CEDB on every request.
	 */
	public synchronized String getNextSeqNumber(String referenceCode,
			Integer noOfDigits,Session session) {
		
		Criteria criteria = session.createCriteria(BomnrSeqNumberDo.class);
		criteria.add(Restrictions.eq("referenceCode",referenceCode));
		 
		sequenceNumbersDo = (BomnrSeqNumberDo)criteria.uniqueResult();
		
		int runningNumber;
		if(sequenceNumbersDo!=null)
		{
		
			session.refresh(sequenceNumbersDo);
			runningNumber = updateRecord(sequenceNumbersDo,session);
			if(oldRunningNumber==runningNumber && oldRefCode.equals(referenceCode)){//to avoid duplicates
				Criteria criteria1 = session.createCriteria(BomnrSeqNumberDo.class);
				criteria1.add(Restrictions.eq("referenceCode",referenceCode));
				 
				sequenceNumbersDo = (BomnrSeqNumberDo)criteria1.uniqueResult();
				runningNumber = updateRecord(sequenceNumbersDo,session);
			}
		}
		else
		{
			runningNumber = pushRecord(referenceCode,session);
		}
		oldRunningNumber=runningNumber;
		oldRefCode = referenceCode;
		return buildSeqNumber(referenceCode, noOfDigits, runningNumber);
	}

	private String buildSeqNumber(String referenceCode, Integer noOfDigits,
			int runningNumber) {
		StringBuffer sb = new StringBuffer(noOfDigits);
		sb.append(runningNumber);
		int noOfPads = noOfDigits - sb.length();
		// TODO: decide what to do if noOfPads is negative
		while (noOfPads-- > 0) {
			sb.insert(0, '0');
		}
		sb.insert(0, referenceCode);
		return sb.toString();
	}

	private int pushRecord(String referenceCode,Session session) {
		BomnrSeqNumberDo sequenceNumbersDo = new BomnrSeqNumberDo(
				referenceCode, 1);
		// NOTE: Hard coding to zero
		session.persist(sequenceNumbersDo);
		return sequenceNumbersDo.getRunningNumber();
	}

	private int updateRecord(BomnrSeqNumberDo sequenceNumbersDo,Session session) {
		int runningnumber=0;
		sequenceNumbersDo.setRunningNumber(sequenceNumbersDo.getRunningNumber() + 1);

		
        session.persist(sequenceNumbersDo);
		session.flush();
		session.refresh(sequenceNumbersDo);
		Criteria criteria = session.createCriteria(BomnrSeqNumberDo.class);
		criteria.add(Restrictions.eq("referenceCode",sequenceNumbersDo.getReferenceCode()));
		 
		BomnrSeqNumberDo retDto1 = (BomnrSeqNumberDo)criteria.uniqueResult();
		
		if(retDto1!=null){
			runningnumber=retDto1.getRunningNumber();
		}
	
		return runningnumber;
	}
}